#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <unistd.h>
#include <sys/socket.h>
#include <sys/un.h>
#include <stdbool.h>
#include <string.h>
#include <time.h>
#include "types.h"
#include "const.h"
#include "util.h"
#include <ctype.h>
#include <pthread.h>
#include <limits.h>

int n;

typedef struct {
    unsigned int *numbers;
} compute_prime_struct;

int target;
bool found = false;
int max_threads;
int part = 0;
// TODO: implement
bool serial_binsearch(unsigned int buf2[], int n) {
    int done = false;
    int low = 0, mid, high = n-1; // define the lowest, mid and highest positions
    while (low <= high && !found) {
         mid = (low + high) / 2;
         if (buf2[mid] < target) {
            low = mid + 1;
        }
         else if (buf2[mid]> target) {
            high = mid - 1;
        }
        else if (buf2[mid]== target)  {
            done = true;
            break;
        }
     }
     return done;  
}

// TODO: implement

void* parallel_binsearch(void* args) {
    compute_prime_struct *actual_args = args;
    part++;
    int thread_part = part;
    int mid;
    int low = thread_part * (n / max_threads);
    int high = (thread_part + 1) * (n / max_threads);
    while (low < high && !found)  {
        mid = (high - low) / 2 + low;
        if ( actual_args->numbers[mid] == target)  {
            found = true;
            break;
        }
        else if ( actual_args->numbers[mid] > target)
            high = mid - 1;
        else
            low = mid + 1;
    }
    free(actual_args);
    return NULL;
}

char *socket_path = "/tmp/dg.sock";;
int main(int argc, char** argv) {

    /* TODO: parse arguments with getopt */
    int E_value;
    int T_value;
    int P_value;

    int index;
    int c;

    opterr = 0;

    if (argc == 1) {
        fprintf(stderr, "[binsearch] No arguments where given\n");
        exit(-2);
    }

    while( (c = getopt(argc, argv, "E:T:P:")) != -1) {
        switch(c) {
            case 'E':
                E_value = atoi(optarg);
                break;
            case 'T':
                T_value = atoi(optarg);
                break;
            case 'P':
                P_value = atoi(optarg);
                break;
            case '?':
                if (isprint (optopt))
                    fprintf (stderr, "Unknown option `-%c'.\n", optopt);
                else
                    fprintf (stderr, "Unknown option character `\\x%x'.\n", optopt);
                return 1;
            default: 
                abort();
        }

    }

    /*Here we check that flag values are in the correct ranges*/
    if (E_value < 1) {
        fprintf(stderr, "[binsearch] Invalid value for E flag\n");
    }
    else if (T_value < 3 || T_value > 9) {
        fprintf(stderr, "[binsearch] Invalid value for T flag\n");
    }
    else if (P_value < 0 || P_value > pow(10, T_value) - 1) {
        fprintf(stderr, "[binsearch] Invalid value for P flag\n"); 
     }
    for (index = optind; index < argc; index++)
        printf ("[binsearch] Non-option argument %s\n", argv[index]);
    


    /* TODO: start datagen here as a child process. */
    int pid = fork();
    if (pid < 0) {
        perror("[binsearch] fork error.");
    }
    else if (pid == 0) {
        if (execv("./datagen", argv) < 0) {
            perror("[binsearch] execv error.");
            exit(-1);
        }
    }


    /* TODO: connect to datagen and ask for the necessary data in each experiment round.
     * Create a Unix domain socket with DSOCKET_PATH (see const.h).
     * Talk to datagen using the messages specified in the assignment description document.
     * Read the values generated by datagen from the socket and use them to run your
     * experiments
     * */
    
    // Variables
    struct sockaddr_un addr;
    char buf[100];
    char buf2[1000];
    int fd, rc, rs;
    unsigned int *datagen_numbers = NULL;
    n = pow(10, T_value); /*Amount of values in the array */
    unsigned int nums[n];

    if ( (fd = socket(AF_UNIX, SOCK_STREAM, 0)) == -1 ){
        perror("[binsearch] socket error");
        exit(-1);
    }

    memset(&addr, 0, sizeof(addr));
    addr.sun_family = AF_UNIX;


    strcpy(addr.sun_path, "/tmp/dg.sock");
    //if (strcmp(socket_path, DSOCKET_PATH) == 0) {
    //    strcpy(addr.sun_path, DSOCKET_PATH);
    //    // *addr.sun_path = DSOCKET_PATH;
    //    strncpy(addr.sun_path + 1, socket_path + 1, sizeof(addr.sun_path - 2));
    //} else {
    //    strncpy(addr.sun_path, socket_path, sizeof(addr.sun_path) - 1);
    //}

    while ( connect(fd, (struct sockaddr*)&addr, sizeof(addr)) == -1){
        perror("[binsearch] connect error");
    }

    if ( connect(fd, (struct sockaddr*)&addr, sizeof(addr)) != -1){
        printf("[binsearch] connected");
        //exit(-1);
    }

    // begin
    while ( (rc = read(STDIN_FILENO, buf, sizeof(buf))) > 0 ){
        if(strcmp(buf, "END")>=0){
            // AQUI DEBERIA TERMINAR EL PROCESO DEL DATAGEN Y SEGUIR CON LO DEL OUTPUT...
            exit(-1);
            break;   
        }
        printf("[binsearch] datagen lee el input \n");
        if(write(fd, buf, rc) != rc){
            printf("[binsearch] binsearch le escribe a datagen\n");

            if (rc > 0){
                printf("[binsearch] rc > 0\n");
            }
            else {
                perror("[binsearch] write error");
                exit(-1);
            }
        }
        int leidos = 0;
        // leo lo que me entrega el servidor
        rs = (int) read(fd, buf2, sizeof(buf2));
        if (rs > 0){
            int i = 0;
            leidos = 4;
            datagen_numbers = (unsigned int *) &buf2 + leidos;
            while(leidos != n) {
                // los primeros 4 chars son: "OK\n\n"
                // aqui se supone que deberia empezar a dar unsigned ints
                nums[i] = datagen_numbers[0];
                printf("%d Numero: %u\n",i, nums[i]);
                *datagen_numbers+=sizeof(unsigned int *);
                if(datagen_numbers[0] <= nums[i]){
                    printf("[DEBUG] anterior: %u, actual: %u ", nums[i], datagen_numbers[0]); 
                }
                leidos = leidos + 1;
                i++;
            }

        }
        memset(buf, 0, sizeof(buf));
        memset(buf2, 0, sizeof(buf2));

    }
    max_threads = sysconf(_SC_NPROCESSORS_ONLN); /* Max amount of processors to be used */
    target = nums[P_value];
    
    printf("[binsearch] Starting up...\n");

    /* Get the number of CPU cores available */
    printf("[binsearch] Number of cores available: '%ld'\n", sysconf(_SC_NPROCESSORS_ONLN));

    /* TODO: implement code for your experiments using data provided by datagen and your
     * serial and parallel versions of binsearch.
     * */

    compute_prime_struct *arguments = malloc(sizeof *arguments);

    for (int i = 0; i < n; ++i)
    {
        arguments->numbers[i] = nums[i];
        
    }

    struct timespec start, finish;
    double elapsed = 0;
    clock_gettime(CLOCK_MONOTONIC, &start);

    pthread_t threads[max_threads];
    for (int i = 0; i < max_threads; i++)
        pthread_create(&threads[i], NULL, parallel_binsearch, arguments);
 
    for (int i = 0; i < max_threads; i++)
        pthread_join(threads[i], NULL);
    if (found) {
        printf("[parallel_binsearch] target %d found.\n", target);
    }
    else {
        printf("[parallel_binsearch] target %d not found.\n", target);
    }

    clock_gettime(CLOCK_MONOTONIC, &finish);
    /* Probe time elapsed. */
    elapsed = (finish.tv_sec - start.tv_sec);
    elapsed += (finish.tv_nsec - start.tv_nsec) / 1000000000.0;

    // Time elapsed in seconds.
    free(arguments);
    printf("%lf\n", elapsed);
    exit(EXIT_SUCCESS);
}
